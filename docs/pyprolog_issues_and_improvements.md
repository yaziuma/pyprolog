# pyprolog の問題点と改善方針

## 1. はじめに

本ドキュメントは、Prolog 処理系ライブラリ `pyprolog` ([robjsliwa/pyprolog](https://github.com/robjsliwa/pyprolog)) の現状分析に基づき、確認された主要な問題点と、それらを解決するための改善方針をまとめたものです。

`pyprolog` は Python で Prolog ライクな機能を提供しますが、いくつかの重要な機能の欠如やバグにより、実用上の課題を抱えています。当初は必要なクラスを継承することでこれらの問題に対処しようと試みましたが、限界があることが判明しました。そのため、ライブラリを fork し、より抜本的な改善を行う方針としました。

本改善においては、**パフォーマンスは一切考慮しない**ものとし、機能の正確性と網羅性を優先します。

## 2. pyprolog の主な問題点

### 2.1. パーサーの問題: 空リスト `[]` の誤解釈

- **現象:** Prolog コード中の空リスト `[]` が、要素が空リストであるリスト `[[]]` (Python のネイティブリスト) として誤って解釈される。
- **原因:** `parser.py` の `_parse_list` メソッドにおいて、空リストを処理する特別なロジックが欠如している。本来 `Dot.from_list([])` として表現されるべきものが、誤った内部表現になっている。
- **影響:** リスト操作を含む多くのルール (例: `sum_list([], 0).`) が期待通りにマッチングせず、`AttributeError: 'list' object has no attribute 'match'` や `AttributeError: 'list' object has no attribute 'substitute'` といったエラーを引き起こす。また、リストを表現する `Dot` クラスと `Bar` クラスの設計、特に `Dot.from_list([])` が `Dot([])` という内部構造を持つ点は、Prolog の伝統的な空リストアトム `[]` との比較において直感的でない可能性があり、パーサーやインタプリタのリスト処理全体の複雑性の一因となっている可能性があります。

### 2.2. インタプリタの問題

#### 2.2.1. カット演算子 (`!`) の処理不備

- **現象:** ルールのボディ部がカット `!` のみの場合 (例: `some_rule :- !.`) に `AttributeError: 'Cut' object has no attribute 'query'` が発生する。
- **原因:**
  - `interpreter.py` の `Conjunction.query` メソッドにおけるカット処理ロジックが不完全。カット後のバックトラッキングを適切に防止する機構が不足している。
  - `builtins.py` で定義されている `Cut` クラスに `query` メソッドが実装されていない。
  - さらに、`builtins.Cut` クラスの `match` メソッドが常に空の束縛 `{}` で成功する点は、カットが単一化の対象となった場合の挙動として適切か、検討の余地がある。
- **影響:** カットを用いた制御フローが正しく機能せず、意図しない動作やエラーが発生する。

#### 2.2.2. 変数束縛と再帰ルールの処理不備

- **現象:** 再帰的なルール評価において、変数束縛が正しく伝播されず、`AttributeError: 'NoneType' object has no attribute 'get'` (Variable.substitute 内) が発生する。
- **原因:**
  - `types.py` の `Variable.substitute` メソッドや `merge_bindings.py` の `merge_bindings` 関数が、深い再帰的な束縛の伝播を適切に処理できていない可能性がある。
  - `interpreter.py` の `evaluate_rules` メソッドでの再帰評価時に、変数束縛の管理が不十分で、束縛情報が失われる (e.g., `bindings` が `None` になる)。
- **影響:** 再帰呼び出しを伴う述語 (例: `pow_10/2`) が正しく動作しない。

#### 2.2.3. `is` 述語と変数束縛の不備

- **現象:** `is` 述語による算術評価と変数束縛の過程で `AttributeError: 'NoneType' object has no attribute 'get'` が発生する。
- **原因:** インタプリタが `is` 述語の評価結果や、その結果に基づく変数束縛の伝播を正しく処理できていない。
- **影響:** 算術演算とそれを用いた変数束縛が信頼できない。

### 2.3. 算術演算機能の不足

- **現象:** 標準的な Prolog で利用可能な算術演算子 (例: `mod`, 整数除算 `div` や `//`) が実装されていない。
- **原因:**
  - `math_interpreter.py` の `_compute_binary_operand` メソッドが基本的な四則演算のみをサポートしている。
  - `types.py` の `Number` クラスに必要な算術メソッドが実装されていない。
- **影響:** 剰余や整数除算を必要とする述語 (例: `number_to_digits/2`, `divide/4`) を直接実装できず、ダミー値を用いたり、複雑な代替ロジックを Prolog コード側で記述する必要がある。

### 2.4. `prolog.types.FALSE` の扱いの問題

- **現象:** クエリが論理的に偽 (例: ゼロ除算など) となった場合、`pieprolog` は内部的に `prolog.types.FALSE` を含む解を返す。しかし、`prolog_wrapper.py` の `query` メソッドがこれを適切に処理できず、空のリスト `[]` を返してしまう。
- **原因:** `prolog_wrapper.py` の `query` メソッドが、`prolog.types.FALSE` を Prolog の失敗として解釈するロジックを持たない。加えて、`types.FALSE` クラスの `substitute` メソッドが空の辞書 `{}` を返す点は、他の `Term` オブジェクトの `substitute` が `Term` インスタンスを返す挙動と一貫性がなく、これがラッパーやインタプリタの処理で予期せぬ問題を引き起こす一因となっている可能性がある。
- **影響:** テストにおいて、期待される `False` (失敗) と実際の返り値 `[]` (解なし) が一致せず、アサーションエラーが発生する。

## 3. 改善方針

上記の問題点を解決するため、以下の改善方針を提案します。

### 3.1. パーサーの修正 (`parser.py`)

- **空リストの解釈修正:** `_parse_list` メソッドを修正し、Prolog コード中の空リスト `[]` が、`pieprolog` の内部表現である `Dot.from_list([])` (またはそれに相当する適切な空リスト表現) として正しく解析されるようにする。Python のネイティブリスト `[[]]` として解釈される問題を解消する。
- **リスト表現の改善:** リスト表現に関しては、`Dot` および `Bar` クラスの設計を見直し、Prolog のリスト構造（特に空リストや `[H|T]` 形式）をより直感的かつ堅牢に扱える内部表現とパーサーロジックを検討する。

### 3.2. インタプリタの修正 (`interpreter.py`, `builtins.py`)

- **カット演算子の処理改善:**
  - `Conjunction.query` メソッド内のカット処理ロジックを全面的に見直し、カットが実行された場合に適切にバックトラッキングを停止させるようにする。
  - `Cut` オブジェクトが `query` メソッドを持たない問題については、インタプリタが `Cut` オブジェクトを特別に認識して処理するよう修正するか、あるいは `Cut` クラス (および関連する `builtins.Cut`) に適切な `query` メソッド（またはインタプリタから呼び出されるインターフェース）を実装する。
  - `Cut` オブジェクトの `match` メソッドの挙動を再検討し、カットが単一化の対象となった場合にインタプリタが期待する動作と整合するように修正する。
- **変数束縛と再帰処理の改善:**
  - `Variable.substitute`、`merge_bindings`、および `evaluate_rules` における変数束縛の管理と伝播ロジックを強化する。特に、再帰呼び出しの際に親の束縛情報が正しく子に引き継がれ、子の結果が親に正しく反映されるようにする。束縛辞書が `None` になるケースを避ける。
- **`is` 述語の処理改善:** `is` 述語の評価ロジックと、その結果を変数に束縛する際の処理を確実なものにする。束縛の伝播ミスを防ぐ。

### 3.3. 算術演算機能の拡充 (`math_interpreter.py`, `types.py`)

- **`mod` 演算子の追加:** `MathInterpreter` および `Number` クラスに `mod` (剰余) 演算子をサポートする機能を追加する。
- **整数除算の追加:** 同様に、整数除算 (Prolog の `//` や `div` に相当する機能) を追加する。
- **その他の有用な算術関数の検討:** 必要に応じて、他の標準的な Prolog 算術関数 (例: `abs/1`, `sqrt/1` など) の追加も検討する (ただし優先度は低い)。

### 3.4. `prolog_wrapper.py` の修正

- **`FALSE` の取り扱い改善:** `query` メソッドを修正し、`pieprolog` から `prolog.types.FALSE` を含む解が返された場合に、これを Prolog のクエリ失敗として解釈し、Python の `False` を返すようにする。これにより、テストの期待値との整合性を取る。
- **`FALSE` クラスの挙動修正検討:** `FALSE` クラスの `substitute` メソッドの挙動を、他の `Term` オブジェクトと一貫性のあるもの（例：`self` を返す）に修正することを検討し、インタプリタおよびラッパーでの混乱を避ける。

## 4. まとめ

これらの改善を実施することにより、`pyprolog` の基本的な Prolog 処理系としての信頼性と機能性が大幅に向上することが期待されます。特に、パーサーとインタプリタの修正は、多くのテスト失敗の根本原因を解決するために不可欠です。算術演算機能の拡充は、より実用的な Prolog プログラムの記述を可能にします。

前述の通り、これらの改善は機能の正確性を最優先とし、パフォーマンスは現時点では考慮しません。
