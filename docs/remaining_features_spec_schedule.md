# Prologインタープリタ改善計画：残りのタスク、仕様、スケジュール案

## はじめに

この文書は、Prologインタープリタの未実装機能に関する改修仕様の概要と、今後の開発スケジュール案をまとめたものです。ここでのスケジュールは相対的な目安であり、具体的な期日を示すものではありません。

## 1. 未実装項目一覧

以下に、現時点で未実装または対応が不完全と判断される主要な述語および機能を示します。

**述語:**
- `asserta/1`
- `assertz/1`
- `\=/2` (項非単一化)
- `member/2`
- `append/3`
- `findall/3`
- `throw/1`
- `catch/3`

**機能:**
- 再帰処理の完全な動作検証と必要な修正
- E2Eテスト (`test_simple_queries`, `test_complex_unification`) の実行と対応
- DCG (Definite Clause Grammars) サポート
- モジュールシステム
- 各種最適化・プロファイリング機能

## 2. 各未実装項目の改修仕様案

### 2.1. `asserta/1`

- **機能概要:** 節 (ファクトまたはルール) をデータベースの先頭に追加する。
- **期待される振る舞い:**
  - クエリ: `asserta(p(1)). findall(X, p(X), List).`
  - 期待結果: `List = [1]` (他のp/1の節があればその先頭)
  - クエリ: `asserta((q(X) :- X > 0)). q(5).`
  - 期待結果: `true`
- **引数の型とモード:** `asserta(+Clause)`
  - `Clause`: 呼び出し可能な項 (ファクトまたはルール)
- **主要なエラーケースまたは失敗条件:**
  - `Clause` が呼び出し可能な項でない場合: 型エラー
  - `Clause` が不正な形式の節である場合: ドメインエラーまたは構文エラー

### 2.2. `assertz/1`

- **機能概要:** 節 (ファクトまたはルール) をデータベースの末尾に追加する。
- **期待される振る舞い:**
  - クエリ: `p(1). assertz(p(2)). findall(X, p(X), List).`
  - 期待結果: `List = [1,2]` (他のp/1の節があればその末尾)
- **引数の型とモード:** `assertz(+Clause)`
  - `Clause`: 呼び出し可能な項 (ファクトまたはルール)
- **主要なエラーケースまたは失敗条件:**
  - `asserta/1` に準ずる。

### 2.3. `\=/2` (項非単一化)

- **機能概要:** 二つの項 `Term1` と `Term2` が単一化できない場合に成功する。
- **期待される振る舞い:**
  - クエリ: `a \= b.`
  - 期待結果: `true`
  - クエリ: `X \= a, X = b.`
  - 期待結果: `false` (または解なし)
  - クエリ: `a \= a.`
  - 期待結果: `false`
- **引数の型とモード:** `Term1 \= Term2` (両引数とも `?` だが、通常は具体化された項)
- **主要なエラーケースまたは失敗条件:**
  - 通常はエラーを発生させず、単一化可能なら失敗、不可能なら成功する。

### 2.4. `member/2`

- **機能概要:** 指定された要素がリストのメンバーであるか検査する。あるいはリストの要素を順に生成する。
- **期待される振る舞い:**
  - クエリ: `member(a, [a,b,c]).`
  - 期待結果: `true`
  - クエリ: `member(x, [a,b,c]).`
  - 期待結果: `false`
  - クエリ: `member(X, [a,b]).`
  - 期待結果: `X = a` ; `X = b`
- **引数の型とモード:** `member(?Element, ?List)`
  - `Element`: 項
  - `List`: リスト
- **主要なエラーケースまたは失敗条件:**
  - `List` がリストでない場合: 型エラー

### 2.5. `append/3`

- **機能概要:** 二つのリストを連結して第三のリストを生成する。または、一つのリストを二つのリストに分割する。
- **期待される振る舞い:**
  - クエリ: `append([a,b], [c,d], L).`
  - 期待結果: `L = [a,b,c,d]`
  - クエリ: `append(L1, L2, [a,b,c]).`
  - 期待結果: `L1 = [], L2 = [a,b,c]` ; `L1 = [a], L2 = [b,c]` ; ... ; `L1 = [a,b,c], L2 = []`
- **引数の型とモード:** `append(?List1, ?List2, ?List3)`
- **主要なエラーケースまたは失敗条件:**
  - いずれかの引数が期待されるリスト構造でない場合（部分リストなど）: 型エラー

### 2.6. `findall/3`

- **機能概要:** 指定されたゴールの解を全て集め、リストとして返すメタ述語。解は重複を許す。解の順序は通常、Prologエンジンが見つける順。
- **期待される振る舞い:**
  - クエリ: `p(a). p(b). p(a). findall(X, p(X), List).`
  - 期待結果: `List = [a,b,a]`
  - クエリ: `findall(t(X,Y), (member(X,[1,2]), member(Y,[a,b])), Results).`
  - 期待結果: `Results = [t(1,a), t(1,b), t(2,a), t(2,b)]` (順序は実装依存の可能性あり)
  - クエリ: `findall(X, fail, List).`
  - 期待結果: `List = []`
- **引数の型とモード:** `findall(?Template, +Goal, ?List)`
  - `Template`: 項 (通常は `Goal` 中の変数を含む)
  - `Goal`: 呼び出し可能な項
  - `List`: リスト (通常は出力)
- **主要なエラーケースまたは失敗条件:**
  - `Goal` が呼び出し可能な項でない場合: 型エラー
  - `Goal` の実行中に例外が発生した場合: その例外を再送出する。

### 2.7. `throw/1`

- **機能概要:** 例外を送出する。送出された例外は `catch/3` で捕捉できる。
- **期待される振る舞い:**
  - クエリ: `throw(my_error).`
  - 期待結果: (捕捉されなければ) エラー終了
- **引数の型とモード:** `throw(+ExceptionTerm)`
  - `ExceptionTerm`: 任意の項
- **主要なエラーケースまたは失敗条件:**
  - `ExceptionTerm` が変数である場合: インスタンス化エラー

### 2.8. `catch/3`

- **機能概要:** `Goal` を実行し、もし `Goal` の実行中に `Catcher` に単一化可能な例外が `throw/1` によって送出された場合、`Handler` を実行する。
- **期待される振る舞い:**
  - クエリ: `catch(throw(error1), error1, write('caught error1')).`
  - 期待結果: 標準出力に `caught error1` と表示され、成功。
  - クエリ: `catch((write('ok'), throw(error2)), error1, write('caught error1')).`
  - 期待結果: 標準出力に `ok` と表示され、その後 `error2` が送出され、捕捉されずにエラー終了 (または上位の `catch` へ)。
- **引数の型とモード:** `catch(+Goal, ?Catcher, +Handler)`
  - `Goal`: 呼び出し可能な項
  - `Catcher`: 項 (例外と単一化されるパターン)
  - `Handler`: 呼び出し可能な項
- **主要なエラーケースまたは失敗条件:**
  - `Goal` または `Handler` が呼び出し可能な項でない場合: 型エラー

### 2.9. 再帰処理の完全な動作検証と必要な修正
- **機能概要:** 再帰的なルール定義（例: リスト処理、グラフ探索など）が、無限ループや不適切な結果を生じることなく、正しく終了し期待される解を返すことを保証する。
- **期待される振る舞い:**
  - `member/2` や `append/3` のような典型的な再帰述語が正しく動作する。
  - `ancestor(X,Y) :- parent(X,Y). ancestor(X,Y) :- parent(X,Z), ancestor(Z,Y).` のようなルールが、有限のデータに対して有限個の解を正しく返す。
  - `test_recursive_rules` がパスする。
- **主要なエラーケースまたは失敗条件:**
  - 不適切な再帰定義による無限ループ（これはユーザーの責任だが、Prologエンジンがスタックオーバーフローなどで安全に停止することが望ましい）。
  - 単一化やバックトラックのロジックの誤りによる、誤った解や解の見逃し。

### 2.10. E2Eテストの実行と対応
- **機能概要:** `tests/integration/test_end_to_end.py` に記述されている `test_simple_queries` と `test_complex_unification` を実行し、パスするようにインタープリタ全体を調整・修正する。
- **期待される振る舞い:** 上記テストが全て成功する。
- **主要なエラーケースまたは失敗条件:** テストケースごとに異なる。インタープリタの様々なコンポーネント（パーサー、単一化、ルール解決、組み込み述語など）の組み合わせで問題が発生しうる。

### 2.11. DCG (Definite Clause Grammars) サポート
- **機能概要:** Prologの文法記述のための便利な糖衣構文（例: `sentence --> noun_phrase, verb_phrase.`）をサポートし、それを内部的に通常のProlog節に展開して実行できるようにする。
- **期待される振る舞い:**
  - 簡単なDCGルールを定義し、`phrase/2` や `phrase/3` 述語でパースが実行できる。
- **主要なエラーケースまたは失敗条件:**
  - DCGルールの展開エラー、`phrase/2,3` の未実装または不具合。

### 2.12. モジュールシステム
- **機能概要:** コードをモジュール単位で分割し、名前空間の衝突を避け、述語の可視性（エクスポート/インポート）を制御する仕組みを提供する。
- **期待される振る舞い:**
  - モジュールの定義、述語のエクスポート、他モジュールからのインポートができる。
- **主要なエラーケースまたは失敗条件:**
  - モジュール関連の構文エラー、存在しないモジュールや述語のインポートなど。

### 2.13. 各種最適化・プロファイリング機能
- **機能概要:** (具体的な内容は未定) 末尾再帰最適化、インデックス作成、実行時間やメモリ使用量のプロファイリングなど、インタープリタの性能向上やデバッグ支援のための機能。
- **期待される振る舞い:** 実装される機能による。
- **主要なエラーケースまたは失敗条件:** 実装される機能による。

## 3. 実装スケジュール案

以下に、未実装項目の実装順序案と相対的な工数の目安を示します。これはあくまで提案であり、状況に応じて変更される可能性があります。

| フェーズ | No. | 項目名                                      | 相対工数 | 備考                                       |
|----------|-----|---------------------------------------------|----------|--------------------------------------------|
| 1        | 1   | `asserta/1`, `assertz/1`                    | 中       | 動的DB操作。テスト容易性向上                |
| 1        | 2   | `\=/2` (項非単一化)                         | 小       | 基本的な比較述語                           |
| 1        | 3   | 再帰処理の安定化・修正                      | 中       | `test_recursive_rules` パス目標            |
| 2        | 4   | `member/2`                                  | 小       | 基本的なリスト操作                         |
| 2        | 5   | `append/3`                                  | 小       | 基本的なリスト操作                         |
| 2        | 6   | `findall/3`                                 | 中       | メタ述語。これ以前の安定性が前提           |
| 3        | 7   | `throw/1`                                   | 小       | 例外処理の基本                             |
| 3        | 8   | `catch/3`                                   | 中       | 例外処理の基本                             |
| 4        | 9   | E2Eテスト対応 (`test_simple_queries`他)     | 中～大   | 全体的な動作確認と修正                     |
| 4        | 10  | DCGサポート                                 | 大       | 高度な機能                                 |
| 4        | 11  | モジュールシステム                          | 大       | 高度な機能                                 |
| 4        | 12  | 各種最適化・プロファイリング機能            | 大～特大 | 将来的な拡張                               |

## 4. 現在の課題

### 4.1. `append/3` のテスト実行環境の問題

`append/3` 述語のロジック実装とテストケースの作成は進んでいますが、テスト実行環境 (`pytest`) において、`prolog/runtime/builtins.py` ファイルの古いキャッシュが参照され続け、修正済みの構文エラーが解消されない問題が発生しています。このため、`append/3` のテストを完全に実行し、動作を検証するには至っていません。

**現状のコード:**
- `prolog/runtime/builtins.py` 内の `AppendPredicate` は、Prologの定義に基づいた改善されたロジックが実装されています。
- `tests/runtime/test_list_operations.py` には、`append/3` の様々な動作モードを検証するためのテストケースが準備されています。

**次のステップ:**
- `pytest` のキャッシュ問題を解決する必要があります。
- 問題解決後、準備されているテストケースを実行し、`append/3` の動作検証を完了させる予定です。
