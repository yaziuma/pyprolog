# Prolog インタープリター修正設計書

## 1. BindingEnvironment の unify メソッド実装

### 1.1 概要

`BindingEnvironment`クラスに単一化機能を追加し、`merge_bindings.py`から要求される高度な機能を提供する。

### 1.2 設計方針

- **責任の明確化**: BindingEnvironment が単一化ロジックを直接持つ
- **LogicInterpreter との役割分担**: LogicInterpreter は高レベルの推論、BindingEnvironment は低レベルの単一化を担当
- **occurs check**: 循環参照の検出機能を内蔵

### 1.3 実装すべきメソッド

#### `unify(self, term1, term2) -> bool`

- **機能**: 2 つの項を現在の環境で単一化
- **戻り値**: 成功時 True、失敗時 False
- **副作用**: 成功時は環境に新しい束縛を追加

#### `occurs_check(self, var, term) -> bool`

- **機能**: 変数が項内に出現するかチェック
- **用途**: 無限構造の防止

#### `dereference(self, term) -> PrologType`

- **機能**: 変数チェーンを辿って最終値を取得
- **循環参照対応**: 訪問済み変数を記録して無限ループを防止

### 1.4 parent 属性の取り扱い

- **None 判定**: parent が None の場合の安全な処理
- **イテレーション**: `for var in self.parent` の代わりに `self.parent.bindings.items()` を使用
- **階層検索**: 親環境も含めた変数検索機能

### 1.5 エラーハンドリング

- **型チェック**: 引数の型を検証
- **単一化失敗**: 失敗時の適切なエラーメッセージ
- **循環参照**: occurs check での循環検出時の処理

## 2. パーサーの引数処理ロジック修正

### 2.1 問題の分析

現在のパーサーは `likes(john, mary)` を以下のように誤解析：

- 期待: `args = [Atom("john"), Atom("mary")]` (長さ 2)
- 実際: `args = [Term(",", [Atom("john"), Atom("mary")])]` (長さ 1)

### 2.2 設計方針

- **コンテキスト認識**: 述語引数内のカンマと論理演算子のカンマを区別
- **演算子優先度**: 引数リスト内では演算子優先度を制限
- **括弧処理**: 引数境界の明確な識別

### 2.3 修正アプローチ

#### `_parse_arguments(self) -> List[PrologType]`

- **新規メソッド**: 引数専用の解析メソッド
- **カンマ処理**: 引数区切りとしてのカンマを特別扱い
- **ネスト対応**: 括弧内の複雑な式も正しく処理

#### `_parse_primary(self)` の修正

- **関数呼び出し検出**: `LEFTPAREN`トークンで引数解析モードに切り替え
- **引数解析委譲**: `_parse_arguments()`を呼び出し

#### `_parse_expression_with_precedence(self, max_precedence, in_args=False)`

- **引数モードフラグ**: `in_args`パラメータで引数内かを判定
- **カンマ演算子制限**: 引数内ではカンマ演算子を無効化

### 2.4 実装詳細

#### 引数解析の状態管理

```
引数解析開始 → LEFTPAREN検出
    ↓
引数項解析 → _parse_term()だが演算子制限あり
    ↓
カンマ検出 → 次の引数へ
    ↓
RIGHTPAREN → 引数解析終了
```

#### エラー回復

- **不完全な引数**: 閉じ括弧なしの場合の処理
- **空引数**: 連続カンマの処理
- **ネスト不整合**: 括弧の対応チェック

## 3. 単項演算子サポートの追加

### 3.1 問題の分析

現在の演算子レジストリには単項マイナス演算子の定義が不足：

```
"-": arity=2 (二項のみ)
必要: arity=1 (単項) + arity=2 (二項)
```

### 3.2 設計方針

- **多重定義**: 同じ記号で異なるアリティの演算子を共存
- **文脈判定**: パーサーが文脈から単項/二項を判定
- **優先度調整**: 単項演算子は高い優先度を設定

### 3.3 演算子レジストリの拡張

#### `OperatorInfo`の拡張

- **オーバーロード対応**: 同じ記号で複数の OperatorInfo を管理
- **文脈識別**: 単項/二項の文脈情報を保持

#### `operator_registry`の修正

```
演算子記号 → List[OperatorInfo]
    例: "-" → [
        OperatorInfo("-", 200, NON, ARITHMETIC, 1, ...),  # 単項
        OperatorInfo("-", 500, LEFT, ARITHMETIC, 2, ...)  # 二項
    ]
```

#### 検索メソッドの拡張

- `get_operator(symbol, arity)`: アリティ指定での検索
- `get_operators_by_symbol(symbol)`: 記号での全候補取得
- `resolve_operator(symbol, context)`: 文脈による解決

### 3.4 パーサーの単項演算子対応

#### 文脈判定ロジック

```
単項演算子の条件:
- 文の開始
- 開き括弧の直後
- 二項演算子の直後
- カンマの直後
```

#### `_parse_primary()`の拡張

- **前置演算子検出**: 単項演算子記号をチェック
- **優先度処理**: 単項演算子の結合性を考慮
- **エラー処理**: 不正な単項演算子使用の検出

### 3.5 MathInterpreter の対応

#### `evaluate_unary_op()`の拡張

- **演算子種類**: `-`, `+`, `abs`などの単項演算子
- **型チェック**: 数値型の検証
- **エラー処理**: 不正な型での単項演算

#### `evaluate()`メソッドの修正

- **アリティ判定**: 引数数による単項/二項の判別
- **適切な評価器選択**: `evaluate_unary_op`または`evaluate_binary_op`

## 4. 統合テストとバリデーション

### 4.1 修正後の検証項目

1. **単一化機能**: 基本的な単一化から複雑な構造まで
2. **引数解析**: 様々な引数パターンの正確な解析
3. **演算子処理**: 単項/二項演算子の正しい判定と評価

### 4.2 回帰テスト

- **既存機能**: 修正により他機能が破綻しないことを確認
- **パフォーマンス**: 大幅な性能劣化がないことを検証

### 4.3 段階的リリース

1. BindingEnvironment 修正 → merge_bindings テスト通過
2. パーサー修正 → parser 引数テスト通過
3. 演算子拡張 → math_interpreter テスト通過

この修正により、失敗している 12 のテストケースが解決され、Prolog インタープリターの基盤がより堅牢になると期待されます。
