# Prologã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ ã‚¹ãƒªãƒ åŒ–å®Ÿè£…ã‚¬ã‚¤ãƒ‰

## Phase 1: é‡è¤‡ã‚¯ãƒ©ã‚¹å‰Šé™¤ï¼ˆæœ€å„ªå…ˆãƒ»ä½ãƒªã‚¹ã‚¯ï¼‰

### 1.1 parser/types.py ã®å®Œå…¨å‰Šé™¤

**ğŸ—‘ï¸ å‰Šé™¤å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `parser/types.py` (146è¡Œ)

ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã‚’å‰Šé™¤ã—ã¾ã™ã€‚ä»¥ä¸‹ã®ã‚¯ãƒ©ã‚¹ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ãŒã€ã™ã¹ã¦ä¸è¦ã¾ãŸã¯é‡è¤‡ã§ã™ï¼š

- `Number` â†’ `core/types.py`ã®`Number`ã§ä»£æ›¿
- `Arithmetic` â†’ æœªä½¿ç”¨ã‚¯ãƒ©ã‚¹
- `Logic` â†’ æœªä½¿ç”¨ã‚¯ãƒ©ã‚¹  
- `TermFunction` â†’ æœªä½¿ç”¨ã‚¯ãƒ©ã‚¹

### 1.2 core/types.py ã® Number ã‚¯ãƒ©ã‚¹å¼·åŒ–

**ğŸ“ å¤‰æ›´å‰** (`core/types.py`):
```python
@dataclass
class Number(BaseTerm):
    value: Union[int, float]

    def __repr__(self):
        return str(self.value)

    def __eq__(self, other):
        return isinstance(other, Number) and self.value == other.value

    def __hash__(self):
        return hash(self.value)
```

**âœ… å¤‰æ›´å¾Œ** (`core/types.py`):
```python
@dataclass
class Number(BaseTerm):
    value: Union[int, float]

    def __repr__(self):
        return str(self.value)

    def __eq__(self, other):
        return isinstance(other, Number) and self.value == other.value

    def __hash__(self):
        return hash(self.value)
    
    # å‹ãƒã‚§ãƒƒã‚¯ç”¨ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆMathInterpreterã§ä½¿ç”¨ï¼‰
    def is_numeric(self) -> bool:
        return True
    
    def to_python_number(self) -> Union[int, float]:
        """Pythonæ•°å€¤å‹ã¸ã®å¤‰æ›"""
        return self.value
```

### 1.3 ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã®ä¿®æ­£

**ğŸ“ å¤‰æ›´å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `runtime/interpreter.py`

**å¤‰æ›´å‰**:
```python
from prolog.parser.types import Number as ParserNumber  # å‰Šé™¤
```

**âœ… å¤‰æ›´å¾Œ**:
```python
# ParserNumberé–¢é€£ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ã™ã¹ã¦å‰Šé™¤
# core/types.Number ã®ã¿ä½¿ç”¨
```

**ğŸ“ å¤‰æ›´å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `prolog/cli/repl.py`

**å¤‰æ›´å‰**:
```python
from prolog.parser.types import Dot, Bar  # å‰Šé™¤
from prolog.core.types import FALSE_TERM as FALSE, CUT_SIGNAL as CUT  # ä¿®æ­£å¿…è¦
```

**âœ… å¤‰æ›´å¾Œ**:
```python
# Dot, Bar ã¯å‰Šé™¤ï¼ˆparser/types.py ã«ã‚ã£ãŸãŒæœªä½¿ç”¨ï¼‰
# FALSE_TERM, CUT_SIGNAL ã¯ core/types.py ã«ç§»å‹•ã¾ãŸã¯å®šæ•°å®šç¾©
```

### 1.4 å®šæ•°ã®çµ±åˆ

**ğŸ“ å¤‰æ›´å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `core/types.py`

**è¿½åŠ **:
```python
# ãƒ•ã‚¡ã‚¤ãƒ«æœ«å°¾ã«è¿½åŠ 
# å®šæ•°å®šç¾©
FALSE_TERM = Atom("false")
TRUE_TERM = Atom("true")
CUT_SIGNAL = Atom("!")

# å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹
FALSE = FALSE_TERM
TRUE = TRUE_TERM
CUT = CUT_SIGNAL
```

## Phase 2: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼çµ±åˆï¼ˆä¸­å„ªå…ˆãƒ»ä¸­ãƒªã‚¹ã‚¯ï¼‰

### 2.1 LogicInterpreter ã® Runtime ã¸ã®çµ±åˆ

**ğŸ—‘ï¸ å‰Šé™¤å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `runtime/logic_interpreter.py` (200è¡Œ)

**ğŸ“ å¤‰æ›´å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `runtime/interpreter.py`

**å¤‰æ›´å‰** (Runtime ã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–):
```python
class Runtime:
    def __init__(self, rules: Optional[List[Union[Rule, Fact]]] = None):
        self.rules: List[Union[Rule, Fact]] = rules if rules is not None else []
        self.math_interpreter = MathInterpreter()
        self.logic_interpreter = LogicInterpreter(self.rules, self)  # å‰Šé™¤
```

**âœ… å¤‰æ›´å¾Œ**:
```python
class Runtime:
    def __init__(self, rules: Optional[List[Union[Rule, Fact]]] = None):
        self.rules: List[Union[Rule, Fact]] = rules if rules is not None else []
        self.math_interpreter = MathInterpreter()
        self._unique_var_counter = 0  # LogicInterpreterã‹ã‚‰ç§»å‹•
        
        # çµ±åˆè¨­è¨ˆï¼šæ¼”ç®—å­è©•ä¾¡ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰
        self._operator_evaluators = self._build_unified_evaluator_system()
```

### 2.2 LogicInterpreter ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ Runtime ã«ç§»å‹•

**âœ… Runtime ã‚¯ãƒ©ã‚¹ã«ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ **:

```python
class Runtime:
    # ... æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ ...
    
    def _rename_variables(self, term_or_rule: Union[PrologType, Rule, Fact]) -> Union[PrologType, Rule, Fact]:
        """ãƒ«ãƒ¼ãƒ«ã¾ãŸã¯é …å†…ã®å¤‰æ•°ã‚’ä¸€æ„ãªåå‰ã«ãƒªãƒãƒ¼ãƒ ã™ã‚‹ï¼ˆLogicInterpreterã‹ã‚‰ç§»å‹•ï¼‰"""
        self._unique_var_counter += 1
        mapping: Dict[str, Variable] = {}
        
        def rename_recursive(current_term: PrologType) -> PrologType:
            if isinstance(current_term, Variable):
                if current_term.name not in mapping:
                    new_name = f"_V{self._unique_var_counter}_{current_term.name}"
                    mapping[current_term.name] = Variable(new_name)
                return mapping[current_term.name]
            elif isinstance(current_term, Term):
                new_args = [rename_recursive(arg) for arg in current_term.args]
                return Term(current_term.functor, new_args)
            elif isinstance(current_term, ListTerm):
                new_elements = [rename_recursive(el) for el in current_term.elements]
                renamed_tail_val = rename_recursive(current_term.tail) if current_term.tail is not None else None
                return ListTerm(new_elements, renamed_tail_val)
            return current_term
        
        if isinstance(term_or_rule, Rule):
            renamed_head = rename_recursive(term_or_rule.head)
            renamed_body = rename_recursive(term_or_rule.body)
            return Rule(renamed_head, renamed_body)
        elif isinstance(term_or_rule, Fact):
            renamed_head = rename_recursive(term_or_rule.head)
            return Fact(renamed_head)
        else:
            return rename_recursive(term_or_rule)
    
    def unify(self, term1: PrologType, term2: PrologType, env: BindingEnvironment) -> Tuple[bool, BindingEnvironment]:
        """2ã¤ã®é …ã‚’ç¾åœ¨ã®ç’°å¢ƒã§å˜ä¸€åŒ–ï¼ˆLogicInterpreterã‹ã‚‰ç§»å‹•ï¼‰"""
        current_env = env.copy()
        t1 = self.dereference(term1, current_env)
        t2 = self.dereference(term2, current_env)
        
        if t1 == t2:
            return True, current_env
        
        if isinstance(t1, Variable):
            if self._occurs_check(t1, t2, current_env):
                return False, env
            current_env.bind(t1.name, t2)
            return True, current_env
            
        if isinstance(t2, Variable):
            if self._occurs_check(t2, t1, current_env):
                return False, env
            current_env.bind(t2.name, t1)
            return True, current_env
        
        if isinstance(t1, Atom) and isinstance(t2, Atom):
            return t1.name == t2.name, current_env
        if isinstance(t1, Number) and isinstance(t2, Number):
            return t1.value == t2.value, current_env
        if isinstance(t1, String) and isinstance(t2, String):
            return t1.value == t2.value, current_env
        
        if isinstance(t1, Term) and isinstance(t2, Term):
            if t1.functor == t2.functor and len(t1.args) == len(t2.args):
                temp_env = current_env.copy()
                for i in range(len(t1.args)):
                    unified, temp_env = self.unify(t1.args[i], t2.args[i], temp_env)
                    if not unified:
                        return False, env
                return True, temp_env
        
        return False, env
    
    def dereference(self, term: PrologType, env: BindingEnvironment) -> PrologType:
        """å¤‰æ•°ã‚’ç’°å¢ƒå†…ã§ãã®å€¤ã«ç½®ãæ›ãˆã‚‹ï¼ˆLogicInterpreterã‹ã‚‰ç§»å‹•ï¼‰"""
        if isinstance(term, Variable):
            bound_value = env.get_value(term.name)
            if bound_value is not None and bound_value != term:
                return self.dereference(bound_value, env)
        return term
    
    def _occurs_check(self, var: Variable, term: PrologType, env: BindingEnvironment) -> bool:
        """occurs checkã®å®Ÿè£…ï¼ˆLogicInterpreterã‹ã‚‰ç§»å‹•ï¼‰"""
        term_deref = self.dereference(term, env)
        if var == term_deref:
            return True
        if isinstance(term_deref, Term):
            for arg in term_deref.args:
                if self._occurs_check(var, arg, env):
                    return True
        return False
    
    def solve_goal(self, goal: Term, env: BindingEnvironment) -> Iterator[BindingEnvironment]:
        """å˜ä¸€ã®ã‚´ãƒ¼ãƒ«ã‚’è§£æ±ºï¼ˆLogicInterpreterã‹ã‚‰ç§»å‹•ãƒ»ç°¡ç´ åŒ–ï¼‰"""
        if isinstance(goal, Atom):
            if goal.name == "true":
                yield env
                return
            elif goal.name == "fail":
                return
        
        if not isinstance(goal, Term):
            raise PrologError(f"Goal must be a Term or Atom, got {type(goal)}: {goal}")
        
        # ã‚«ãƒƒãƒˆã®å‡¦ç†
        if goal.functor.name == "!" and not goal.args:
            yield env
            return
        
        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¤œç´¢
        for db_entry in self.rules:
            renamed_entry = self._rename_variables(db_entry)
            
            if isinstance(renamed_entry, Rule):
                current_head = renamed_entry.head
            elif isinstance(renamed_entry, Fact):
                current_head = renamed_entry.head
            else:
                continue
            
            unified, new_env = self.unify(goal, current_head, env)
            
            if unified:
                if isinstance(renamed_entry, Fact):
                    yield new_env
                elif isinstance(renamed_entry, Rule):
                    yield from self.execute(renamed_entry.body, new_env)
```

### 2.3 execute ãƒ¡ã‚½ãƒƒãƒ‰ã®æ›´æ–°

**å¤‰æ›´å‰**:
```python
def execute(self, goal: Term, env: BindingEnvironment) -> Iterator[BindingEnvironment]:
    # ... æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ ...
    else:
        # é€šå¸¸ã®è¿°èªã¨ã—ã¦å‡¦ç†
        yield from self.logic_interpreter.solve_goal(goal, env)
```

**âœ… å¤‰æ›´å¾Œ**:
```python
def execute(self, goal: Term, env: BindingEnvironment) -> Iterator[BindingEnvironment]:
    # ... æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ ...
    else:
        # é€šå¸¸ã®è¿°èªã¨ã—ã¦å‡¦ç†ï¼ˆçµ±åˆã•ã‚ŒãŸsolve_goalã‚’ä½¿ç”¨ï¼‰
        yield from self.solve_goal(goal, env)
```

### 2.4 ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã®ä¿®æ­£

**ğŸ“ å¤‰æ›´å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `runtime/interpreter.py`

**å¤‰æ›´å‰**:
```python
from prolog.runtime.logic_interpreter import LogicInterpreter
```

**âœ… å¤‰æ›´å¾Œ**:
```python
# LogicInterpreter ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’å‰Šé™¤
# å¿…è¦ãªå‹ã®ã¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from prolog.core.types import Term, Variable, Number, Rule, Fact, Atom, String, ListTerm, PrologType
```

## Phase 3: ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†ã®ç°¡ç´ åŒ–

### 3.1 TokenTypeManager ã®å‰Šé™¤

**ğŸ“ å¤‰æ›´å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `parser/token_type.py`

**å¤‰æ›´å‰**:
```python
class TokenTypeManager:
    # å‹•çš„ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹å…¨ä½“
```

**âœ… å¤‰æ›´å¾Œ**:
```python
# TokenTypeManager ã‚¯ãƒ©ã‚¹ã‚’å®Œå…¨å‰Šé™¤
# ensure_operator_tokens() é–¢æ•°ã‚‚å‰Šé™¤

# é™çš„ãª TokenType enum ã®ã¿ä¿æŒ
class TokenType(Enum):
    # åŸºæœ¬ãƒˆãƒ¼ã‚¯ãƒ³
    ATOM = "ATOM"
    VARIABLE = "VARIABLE"
    NUMBER = "NUMBER"
    STRING = "STRING"
    
    # åŒºåˆ‡ã‚Šæ–‡å­—
    LEFTPAREN = "LEFTPAREN"
    RIGHTPAREN = "RIGHTPAREN"
    LEFTBRACKET = "LEFTBRACKET"
    RIGHTBRACKET = "RIGHTBRACKET"
    COMMA = "COMMA"
    DOT = "DOT"
    BAR = "BAR"
    
    # åˆ¶å¾¡æ§‹é€ 
    COLONMINUS = "COLONMINUS"
    UNDERSCORE = "UNDERSCORE"
    
    # æ¼”ç®—å­ï¼ˆé™çš„å®šç¾©ï¼‰
    PLUS = "PLUS"
    MINUS = "MINUS"
    STAR = "STAR"
    SLASH = "SLASH"
    POWER = "POWER"
    DIV = "DIV"
    MOD = "MOD"
    ARITH_EQ = "ARITH_EQ"
    ARITH_NEQ = "ARITH_NEQ"
    LESS = "LESS"
    LESS_EQ = "LESS_EQ"
    GREATER = "GREATER"
    GREATER_EQ = "GREATER_EQ"
    UNIFY = "UNIFY"
    NOT_UNIFY = "NOT_UNIFY"
    IDENTICAL = "IDENTICAL"
    NOT_IDENTICAL = "NOT_IDENTICAL"
    IS = "IS"
    CUT = "CUT"
    WRITE = "WRITE"
    NL = "NL"
    TAB = "TAB"
    IF_THEN = "IF_THEN"
    SEMICOLON = "SEMICOLON"
    NOT = "NOT"
    
    # ç‰¹æ®Šè¿°èª
    TRUE = "TRUE"
    FAIL = "FAIL"
    RETRACT = "RETRACT"
    ASSERTA = "ASSERTA"
    ASSERTZ = "ASSERTZ"
    
    EOF = "EOF"
```

### 3.2 Scanner ã®ç°¡ç´ åŒ–

**ğŸ“ å¤‰æ›´å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `parser/scanner.py`

**å¤‰æ›´å‰**:
```python
def __init__(self, source: str, report: Callable[[int, str], None] = default_error_handler):
    # ... æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ ...
    # æ¼”ç®—å­ãƒˆãƒ¼ã‚¯ãƒ³ã®åˆæœŸåŒ–
    ensure_operator_tokens()  # å‰Šé™¤
```

**âœ… å¤‰æ›´å¾Œ**:
```python
def __init__(self, source: str, report: Callable[[int, str], None] = default_error_handler):
    # ... æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ ...
    # ensure_operator_tokens() ã®å‘¼ã³å‡ºã—ã‚’å‰Šé™¤
    
    # æ¼”ç®—å­ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’é™çš„å®šç¾©
    self._operator_symbols = {
        "+": TokenType.PLUS,
        "-": TokenType.MINUS,
        "*": TokenType.STAR,
        "/": TokenType.SLASH,
        "**": TokenType.POWER,
        "//": TokenType.DIV,
        "mod": TokenType.MOD,
        "=:=": TokenType.ARITH_EQ,
        "=\\=": TokenType.ARITH_NEQ,
        "<": TokenType.LESS,
        "=<": TokenType.LESS_EQ,
        ">": TokenType.GREATER,
        ">=": TokenType.GREATER_EQ,
        "=": TokenType.UNIFY,
        "\\=": TokenType.NOT_UNIFY,
        "==": TokenType.IDENTICAL,
        "\\==": TokenType.NOT_IDENTICAL,
        "is": TokenType.IS,
        "!": TokenType.CUT,
        "write": TokenType.WRITE,
        "nl": TokenType.NL,
        "tab": TokenType.TAB,
        "->": TokenType.IF_THEN,
        ";": TokenType.SEMICOLON,
        "\\+": TokenType.NOT,
    }
```

**å¤‰æ›´å‰**:
```python
def _build_operator_mapping(self) -> Dict[str, TokenType]:
    """operator_registryã‹ã‚‰æ¼”ç®—å­ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’æ§‹ç¯‰"""
    from prolog.core.operators import operator_registry
    
    mapping = {}
    for symbol, op_info in operator_registry._operators.items():
        token_type = getattr(TokenType, op_info.token_type)
        mapping[symbol] = token_type
    
    return mapping
```

**âœ… å¤‰æ›´å¾Œ**:
```python
# _build_operator_mapping ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‰Šé™¤
# é™çš„ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½¿ç”¨
```

## Phase 4: ãƒ•ã‚¡ã‚¤ãƒ«çµ±åˆ

### 4.1 merge_bindings ã® binding_environment ã¸ã®çµ±åˆ

**ğŸ“ å¤‰æ›´å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `core/binding_environment.py`

**è¿½åŠ ãƒ¡ã‚½ãƒƒãƒ‰**:
```python
class BindingEnvironment:
    # ... æ—¢å­˜ã®ãƒ¡ã‚½ãƒƒãƒ‰ ...
    
    @staticmethod
    def merge(bindings1, bindings2=None):
        """ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’çµåˆã™ã‚‹ï¼ˆmerge_bindings.pyã‹ã‚‰ç§»å‹•ï¼‰"""
        if bindings1 is None:
            return bindings2 if bindings2 is not None else {}
        if bindings2 is None:
            return bindings1
        
        if isinstance(bindings1, BindingEnvironment) and isinstance(bindings2, BindingEnvironment):
            merged_env = bindings1.copy()
            # bindings2ã®å†…å®¹ã‚’çµ±åˆ
            for var_name, value in bindings2.bindings.items():
                merged_env.bind(var_name, value)
            return merged_env
        
        if isinstance(bindings1, BindingEnvironment):
            merged_env = bindings1.copy()
            for var, value in bindings2.items():
                merged_env.bind(var, value)
            return merged_env
        
        if isinstance(bindings2, BindingEnvironment):
            merged_env = bindings2.copy()
            for var, value in bindings1.items():
                merged_env.bind(var, value)
            return merged_env
        
        # ä¸¡æ–¹ãŒè¾æ›¸ã®å ´åˆ
        merged = bindings1.copy()
        merged.update(bindings2)
        return merged
    
    def to_dict(self) -> Dict[str, Any]:
        """è¾æ›¸å½¢å¼ã«å¤‰æ›"""
        result = {}
        for var_name, value in self.bindings.items():
            if value != Variable(var_name):  # è‡ªåˆ†è‡ªèº«ä»¥å¤–ã«ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿
                result[var_name] = value
        return result
```

**ğŸ—‘ï¸ å‰Šé™¤å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `core/merge_bindings.py` (150è¡Œ)

### 4.2 ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã®æ›´æ–°

**ğŸ“ å¤‰æ›´å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: `runtime/builtins.py`

**å¤‰æ›´å‰**:
```python
from prolog.core.merge_bindings import merge_bindings
```

**âœ… å¤‰æ›´å¾Œ**:
```python
# merge_bindings ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’å‰Šé™¤
# BindingEnvironment.merge ã‚’ä½¿ç”¨
```

**ä½¿ç”¨ç®‡æ‰€ã®ä¿®æ­£**:
```python
# å¤‰æ›´å‰
unified = merge_bindings(match_result_bindings, bindings)

# å¤‰æ›´å¾Œ
unified = BindingEnvironment.merge(match_result_bindings, bindings)
```

## å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### âœ… Phase 1 ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] `parser/types.py` ã®å‰Šé™¤
- [ ] `core/types.py` ã¸ã®å®šæ•°è¿½åŠ 
- [ ] ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã®ä¿®æ­£
- [ ] ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç¢ºèª

### âœ… Phase 2 ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ  
- [ ] `runtime/logic_interpreter.py` ã®å‰Šé™¤
- [ ] Runtime ã‚¯ãƒ©ã‚¹ã¸ã®ãƒ¡ã‚½ãƒƒãƒ‰ç§»å‹•
- [ ] å¾ªç’°ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®è§£æ¶ˆ
- [ ] execute ãƒ¡ã‚½ãƒƒãƒ‰ã®æ›´æ–°
- [ ] ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç¢ºèª

### âœ… Phase 3 ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] TokenTypeManager ã®å‰Šé™¤
- [ ] Scanner ã®é™çš„ãƒãƒƒãƒ”ãƒ³ã‚°åŒ–
- [ ] å‹•çš„ãƒˆãƒ¼ã‚¯ãƒ³æ©Ÿèƒ½ã®é™¤å»
- [ ] ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç¢ºèª

### âœ… Phase 4 ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] `core/merge_bindings.py` ã®å‰Šé™¤
- [ ] BindingEnvironment ã¸ã®æ©Ÿèƒ½çµ±åˆ
- [ ] å…¨ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã®æœ€çµ‚ç¢ºèª
- [ ] å®Œå…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

## æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ

- **ã‚³ãƒ¼ãƒ‰è¡Œæ•°**: 1,000è¡Œå‰Šæ¸›ï¼ˆç´„40%å‰Šæ¸›ï¼‰
- **ãƒ•ã‚¡ã‚¤ãƒ«æ•°**: 16å€‹ â†’ 11å€‹ï¼ˆ5å€‹å‰Šé™¤ï¼‰
- **ã‚¯ãƒ©ã‚¹æ•°**: 24å€‹ â†’ 16å€‹ï¼ˆ8å€‹å‰Šé™¤ï¼‰
- **ä¿å®ˆæ€§**: é‡è¤‡æ’é™¤ã«ã‚ˆã‚Šå¤§å¹…å‘ä¸Š
- **ç†è§£ã—ã‚„ã™ã•**: è²¬å‹™ã®æ˜ç¢ºåŒ–ã«ã‚ˆã‚Šå‘ä¸Š

ã“ã®æ®µéšçš„ãªãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã«ã‚ˆã‚Šã€æ©Ÿèƒ½ã‚’æãªã†ã“ã¨ãªãå¤§å¹…ãªã‚¹ãƒªãƒ åŒ–ãŒå®Ÿç¾ã§ãã¾ã™ã€‚