# PyProlog 日本語変数サポート改修設計書

## 1. 概要

### 1.1 目的

Prolog 標準の英語大文字変数制約を維持しつつ、日本語変数をサポートすることで実用性を向上させる。

### 1.2 基本方針

- 入力時：日本語変数を内部的に英語大文字変数にマッピング
- 処理時：既存の Prolog 処理エンジンをそのまま利用
- 出力時：英語大文字変数を元の日本語変数に復元して表示

## 2. アーキテクチャ設計

### 2.1 変数マッピングシステム

```
日本語変数 ⟷ 内部英語変数マッピング管理
- 双方向マッピング辞書の管理
- セッション単位でのマッピング状態保持
- 変数名の一意性保証
```

### 2.2 処理フロー

```
入力 → 変数変換 → Prolog処理 → 結果変換 → 出力
  ↓        ↓         ↓         ↓        ↓
日本語   英語変数   既存処理   英語結果  日本語
```

## 3. 主要コンポーネント設計

### 3.1 VariableMapper クラス

**責務：** 日本語変数と英語変数の相互変換管理

**主要機能：**

- 日本語変数名の検証とマッピング
- 英語変数名の自動生成（V1, V2, V3...形式）
- マッピング状態の管理とクリア
- 変数名衝突の回避

**メソッド設計：**

- `map_japanese_to_english(japanese_var: str) -> str`
- `map_english_to_japanese(english_var: str) -> str`
- `is_japanese_variable(var_name: str) -> bool`
- `clear_mapping()`
- `get_all_mappings() -> Dict[str, str]`

### 3.2 変数変換処理の統合ポイント

#### 3.2.1 Scanner クラス拡張

**対象ファイル：** `pyprolog/parser/scanner.py`

**変更点：**

- `_identifier()` メソッドに日本語変数検出ロジック追加
- 日本語変数の場合、VariableMapper を使用して英語変数に変換
- TokenType は既存の VARIABLE を維持

#### 3.2.2 Parser クラス拡張

**対象ファイル：** `pyprolog/parser/parser.py`

**変更点：**

- Variable オブジェクト生成時の名前変換対応
- 既存の解析ロジックは変更せず、変数名のみ変換

#### 3.2.3 Runtime クラス拡張

**対象ファイル：** `pyprolog/runtime/interpreter.py`

**変更点：**

- `query()` メソッドの結果変換処理追加
- 解の辞書のキー（Variable）を日本語変数名に復元
- 値の中の変数名も再帰的に復元

## 4. 日本語変数の識別ルール

### 4.1 日本語変数の定義

- ひらがな、カタカナ、漢字で始まる変数名
- Unicode 文字クラス：Hiragana, Katakana, CJK Unified Ideographs
- 英数字、アンダースコアとの組み合わせ可

### 4.2 変数名パターン例

```
有効な日本語変数：
- あいうえお
- カタカナ変数
- 漢字変数
- あいう123
- カタカナ_変数

無効（既存ルール維持）：
- _変数（アンダースコア開始）
- 123変数（数字開始）
```

## 5. 実装対象ファイル

### 5.1 新規作成ファイル

```
pyprolog/util/variable_mapper.py
- VariableMapperクラス
- 日本語変数検出ユーティリティ
- マッピング管理機能
```

### 5.2 修正対象ファイル

#### 5.2.1 コアファイル

- `pyprolog/parser/scanner.py`
  - 日本語変数の検出と変換
- `pyprolog/parser/parser.py`
  - 変数オブジェクト生成時の名前処理
- `pyprolog/runtime/interpreter.py`
  - クエリ結果の変数名復元

#### 5.2.2 CLI 関連ファイル

- `pyprolog/cli/interactive_repl.py`
  - 表示時の変数名復元
- `pyprolog/cli/simple_interactive.py`
  - 同上

## 6. セッション管理設計

### 6.1 マッピング状態の管理

- Runtime インスタンス単位で VariableMapper を保持
- セッション開始時にマッピング状態をクリア
- 複数クエリ間でマッピング状態を維持

### 6.2 スレッドセーフティ

- 単一セッション内での使用を前提
- マルチスレッド対応は将来課題

## 7. エラーハンドリング設計

### 7.1 変数名衝突の処理

- 自動生成される英語変数名の重複チェック
- 衝突時は連番で回避（V1_1, V1_2...）

### 7.2 不正な日本語変数名

- 既存の Scanner エラーハンドリングを拡張
- 日本語文字でも不正な形式の場合は適切なエラー

## 8. テスト設計

### 8.1 単体テスト

- VariableMapper クラスの各メソッド
- 日本語変数検出ロジック
- マッピングの双方向変換

### 8.2 統合テスト

- 日本語変数を含むクエリの実行
- 複数の日本語変数が混在するケース
- 日本語変数と英語変数の混在

### 8.3 テストケース例

```
// 基本的な日本語変数
好きな食べ物(太郎, X).

// 複雑な日本語変数
親子関係(父親, 子供1), 親子関係(父親, 子供2).

// 混在パターン
likes(太郎, Food), japanese_food(Food).
```

## 9. パフォーマンス考慮事項

### 9.1 マッピング処理のオーバーヘッド

- 変数変換処理は最小限に
- マッピング辞書のサイズ制限考慮

### 9.2 メモリ使用量

- マッピング情報の適切なクリア
- 大量の変数がある場合の対応

## 10. 後方互換性

### 10.1 既存コードへの影響

- 英語変数のみの既存コードは影響なし
- 既存の API は変更なし

### 10.2 設定オプション

- 日本語変数サポートの ON/OFF 機能
- デフォルトは ON とする

## 11. 実装優先度

### 11.1 Phase 1（必須）

- VariableMapper クラスの実装
- Scanner/Parser の基本的な変換機能
- 基本的なクエリ実行での変数名復元

### 11.2 Phase 2（推奨）

- CLI 環境での表示改善
- 詳細なエラーハンドリング
- 包括的なテストケース

### 11.3 Phase 3（将来課題）

- パフォーマンス最適化
- 設定オプションの追加
- より高度な日本語変数ルール

## 12. 注意事項

### 12.1 制約事項

- 変数名の最大長制限
- 使用可能な日本語文字の範囲
- システムの文字エンコーディング依存

### 12.2 今後の拡張性

- 他言語変数のサポート
- カスタム変数命名ルール
- IDE 連携での変数名補完

この設計により、Prolog 標準との互換性を維持しながら、日本語変数の実用的なサポートが実現できます。
