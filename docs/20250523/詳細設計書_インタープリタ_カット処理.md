# 詳細設計書: インタープリタにおけるカット (`!`) の処理

## 1. 概要

本設計書は、PyPrologのインタープリタ (`prolog/runtime/interpreter.py`) におけるカット述語 (`!/0`) の処理を実装または修正するための詳細設計を記述する。カットはPrologのバックトラッキング制御に不可欠な機能であり、不要な探索を打ち切り、解を決定論的にするなどの目的で使用される。

## 2. 現状の問題点

改修概要設計書「4.2 インタープリタ (`prolog/runtime/interpreter.py`) の改修 - 6. カット (`!`) の処理」に記載の通り、`test_cut_predicate` が失敗しており、カット演算子が期待通りにバックトラッキングを制御していないことが示唆される。

カットが正しく動作しないと、意図しない解が生成されたり、パフォーマンスが低下したりする可能性がある。

## 3. 設計方針

カット (`!`) が実行されたとき、そのカットが属するルールの選択ポイント (choice point) よりも新しい選択ポイントを全て破棄し、かつ、そのカットを含むルールの親ゴール (parent goal) に対する他の選択肢 (他のマッチするルール) も試行されないようにする。

これを実現するためには、インタープリタの実行スタックまたは選択ポイントの管理方法に手を入れる必要がある。

1.  **選択ポイント (Choice Point) の概念の明確化:**
    *   選択ポイントは、あるゴールに対して複数のルールがマッチする可能性がある場合や、`Conjunction` 内のゴールが複数の解を返しうる場合に生成される。
    *   選択ポイントには、その時点でのバインディング環境の状態 (トレイルの位置)、次に試すべきルールのインデックス、現在のゴールの情報などが含まれる。

2.  **カットの識別:**
    *   パーサーはカット `!` を特別なアトム (例: `Term('!')` または専用の `CUT_ATOM`) として表現する。
    *   `Runtime.execute` は、この特別なアトムをゴールとして認識する。

3.  **カット実行時の動作:**
    *   カット `!` が実行されると、現在のゴールを呼び出した親ゴールの選択ポイントまで遡り、その選択ポイント以降に作られた全ての選択ポイントを破棄する。
    *   さらに、その親ゴールが他のルールで再試行されるのを防ぐ。つまり、カットが実行されたルールが、その親ゴールに対する最後の選択肢となる。

    具体的な実装方法として、以下のいずれかまたは組み合わせが考えられる。

    *   **カットフラグ/シグナル:** `execute` や `_execute_conjunction` が特別な値 (例: `CUT_SIGNAL`) を返し、呼び出し元がそれに応じて選択ポイントを適切に剪定 (prune) する。
    *   **選択ポイントスタックへの直接操作:** インタープリタが明示的な選択ポイントスタックを管理している場合、カット実行時にスタックを適切な位置まで巻き戻す。

## 4. 具体的な修正箇所と内容

### 4.1 `prolog.runtime.interpreter.Runtime.execute()`

*   **修正内容 (カット `!/0` の処理):**
    *   ゴールがカットアトム (例: `Term('!')`) である場合を検出する。
    *   カットが実行された時点での「親ゴールの選択ポイント」を特定する。これは、現在のルールが呼び出されたときの選択ポイント、あるいは現在の `Conjunction` が開始されたときの選択ポイントに相当する。
    *   この特定された選択ポイントよりも新しい（スタックの上にある）選択ポイントを全て破棄する。
    *   特定された選択ポイント自体も、「これ以上このゴールに対する他の選択肢は試さない」という印をつける (pruneする)。
    *   カット自体は成功 (`TRUE_TERM` を yield) する。

*   **選択ポイントの管理:**
    *   `execute` がユーザー定義述語のルールを試すループに入る前や、`_execute_conjunction` が各ゴールを試す前に、選択ポイントを作成・記録する必要がある。
    *   選択ポイントには、少なくとも以下の情報が含まれるべき:
        *   現在のトレイルの位置 (`binding_env.get_trail_pos()`)。
        *   次に試すべきルールのインデックス (ルール適用の選択ポイントの場合)。
        *   次に試すべき `Conjunction` 内のゴールのインデックスと、そのゴールの現在の解のインデックス (`_execute_conjunction` の選択ポイントの場合)。
        *   **カットによって剪定されるべき深さを示す情報 (カットの親の選択ポイントのIDなど)。**

*   **擬似コードのイメージ (カット処理):**
    ```python
    # execute メソッド内
    if goal == CUT_ATOM: # CUT_ATOM は '!' を表す特別なオブジェクト
        # 現在の選択ポイントスタックから、カットの対象となる選択ポイント (親の選択ポイント) を見つける。
        # 例えば、各選択ポイントに「カットされたらここまで戻る」という情報を持たせるか、
        # 選択ポイント生成時に「この選択ポイントがカットの対象となる深さ」を記録する。
        parent_choice_point_id = self.choice_point_stack.find_cut_target_id()

        # 親の選択ポイント以降の選択ポイントを破棄
        self.choice_point_stack.prune_after(parent_choice_point_id)

        # 親の選択ポイント自体も「これ以上試行しない」ようにマーク
        self.choice_point_stack.mark_as_cut(parent_choice_point_id)

        yield TRUE_TERM # カットは成功する
        return
    ```
    この擬似コードは、明示的な `choice_point_stack` が存在することを前提としている。既存の `binding_env.backtrack_to` と `original_trail_pos` の仕組みだけでは、カットの複雑な制御 (特に親ゴールの他の選択肢の破棄) を実現するのは難しい場合がある。

### 4.2 `prolog.runtime.interpreter.Runtime._execute_conjunction()`

*   **修正・確認内容:**
    *   `_execute_conjunction` が内部のゴールを `execute` で呼び出し、その `execute` が `CUT_SIGNAL` (または同等のカット発生通知) を返した場合、`_execute_conjunction` はそのシグナルをさらに上位に伝播させる。
    *   もしカットが `Conjunction` 内で発生し、そのカットの範囲がその `Conjunction` を含むルールまで及ぶ場合、`Conjunction` の残りのゴールの試行や、現在のゴールの他の解の試行も中止される必要がある。

### 4.3 選択ポイント管理機構 (新規または既存の拡張)

*   **`ChoicePoint` クラス (またはデータ構造):**
    *   `trail_mark`: バインディング環境の状態。
    *   `current_rule_index`: 次に試すルールのインデックス。
    *   `parent_goal_id`: この選択ポイントがどの親ゴールのために作られたか。
    *   `is_pruned_by_cut`: この選択ポイントがカットによって既に剪定されたかを示すフラグ。
    *   `cut_target_depth`: この選択ポイントが作られたときの「カットの深さ」。カット実行時、この深さを持つ選択ポイントまで戻る。

*   **`Runtime.choice_point_stack` (リストなど):**
    *   `execute` がルール選択や `_execute_conjunction` がゴール選択を行う際に、新しい `ChoicePoint` をこのスタックにプッシュする。
    *   バックトラック時 (通常の失敗時) はスタックからポップし、状態を復元して次の選択肢を試す。
    *   カット実行時は、スタックを適切に巻き戻し、関連する `ChoicePoint` に `is_pruned_by_cut = True` を設定する。

## 5. テストケースの例 (`test_cut_predicate` より)

```prolog
% test_cut_predicate.prolog の内容を想定
p(X) :- q(X), !, r(X).
p(other).

q(a).
q(b).

r(a) :- !, write('r(a) called'), nl. % r(a)内のカットはr(a)の他の節をカット
r(a) :- write('r(a) alternative called'), nl. % これは実行されないはず
r(b) :- write('r(b) called'), nl.

?- p(X).
% Expected output (カットが正しく動作する場合):
% r(a) called
% X = a.
% (ここで終了し、p(other) や q(b) からの解は試行されない)

% もし p(X) :- q(X), !, r(X). の q(X) が失敗したら、p(other) は試される。
% 例: q(c) がない場合
% ?- p(c).
% Expected: (q(c)が失敗するので最初のp節は失敗、カットは実行されない)
%           (p(other)が試され、解があればそれが出る。なければfalse)
```

## 6. 懸念事項と対策

*   **カットの範囲の正確な特定:** カットが影響を及ぼす範囲 (どの選択ポイントまで剪定するか) を正確に特定するのが最も難しい部分。通常、カットが書かれている節の親ゴール (その節を呼び出したゴール) に対する選択肢を剪定する。
*   **`_execute_conjunction` との連携:** `Conjunction` 内でカットが実行された場合、そのカットが `Conjunction` を越えて影響を及ぼすか、`Conjunction` 内に留まるか (いわゆる "soft cut" のような振る舞い、Prolog標準の `!/0` はそうではない) を明確にする。標準の `!/0` は `Conjunction` を越えて影響する。
*   **パフォーマンス:** 選択ポイントスタックの管理は、頻繁に行われるため効率的に行う必要がある。

## 7. その他

カットの実装はPrologインタープリタの中でも特に複雑な部分の一つ。Warren Abstract Machine (WAM) のようなProlog実装の詳細を参考にすると、選択ポイントとカットの扱いの理解が深まる。
既存の `CUT_SIGNAL` のような仕組みがある場合、それがどのように選択ポイントの破棄と連携しているかを詳細に追跡・理解することが最初のステップとなる。
