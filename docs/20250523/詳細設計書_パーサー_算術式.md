# 詳細設計書: パーサーにおける算術式 (`is`) の処理改善

## 1. 概要

本設計書は、PyPrologのパーサー (`prolog/parser/parser.py`) における、ルールボディ内の算術式 (`is`) の解釈不備を修正するための詳細設計を記述する。

## 2. 現状の問題点

改修概要設計書「4.1 パーサー (`prolog/parser/parser.py`) の改修 - 1. ルールボディ (`_parse_rule`) における算術式 (`is`) の処理改善」に記載の通り、現状のパーサーは `Y is Expression` のような算術式を含むルールボディを正しく解釈できず、`Expression` 部分が欠落し `test(Y) :- Y.` のように誤ってパースされる。

具体例:
```prolog
add_one(X, Y) :- Y is X + 1.
```
上記ルールが、以下のように解釈される可能性がある。
```
add_one(X, Y) :- Y.
```

これにより、算術演算を伴うルールの定義と実行が不可能になっている。

## 3. 設計方針

`Parser._parse_term` メソッドおよび `Parser._parse_rule` メソッドを修正し、`is` を含む算術式を正しく認識し、適切な構造の項 (Term) として表現できるようにする。

具体的には、`is` 演算子を検知した場合、左辺の変数と右辺の算術式をそれぞれパースし、`Term('is', Variable, ArithmeticExpression)` という形式の項オブジェクトを生成する。この `ArithmeticExpression` は、さらに `_parse_additive_expr` などの既存の算術式パーサーを利用して構築される。

## 4. 具体的な修正箇所と内容

### 4.1 `prolog.parser.parser.Parser._parse_term()`

*   **修正内容:**
    *   現在の `_parse_term` は、アトム、数値、変数、リスト、構造体（ファンクタ形式）をパースするロジックを持つ。ここに、中置演算子としての `is` を認識する処理を追加する。
    *   まず左辺の項 (通常は変数) をパースする。
    *   次に `is` トークンを期待する。
    *   `is` トークンがあれば、右辺の算術式を `_parse_arithmetic_expression()` (または既存の算術式パーサーの適切なエントリーポイント、例: `_parse_additive_expr`) を呼び出してパースする。
    *   左辺の項、`is` 演算子、右辺の算術式から `Term('is', lhs_term, rhs_expression)` を構築して返す。
    *   `is` が見つからない場合は、既存の単項パースロジックを継続する。

*   **擬似コード:**
    ```python
    def _parse_term(self):
        # ... (既存のリスト、構造体などのチェック) ...
        lhs = self._parse_simple_term() # 変数、アトム、数値などをパース

        if self._match(TokenType.IS): # 'is' トークンをチェック
            self._advance() # 'is' を消費
            rhs_expr = self._parse_additive_expr() # または適切な算術式パーサー
            return Term('is', [lhs, rhs_expr]) # Term('is', [Var, Expr]) の形式

        # ... (構造体の引数部分のパースなど、既存のロジック) ...
        # is でなければ lhs がそのまま項となるか、構造体の一部となる
        if self._match(TokenType.LEFT_PAREN):
             # 構造体の処理 (既存のロジック)
             # ...
             return Term(lhs.value, args) # lhs はファンクタ名
        return lhs # 単純な項 (アトム、変数、数値)
    ```
    *注意: `Term` のコンストラクタや引数の形式は既存の実装に合わせる。上記は `Term(name, args_list)` を想定。*

### 4.2 `prolog.parser.parser.Parser._parse_rule()`

*   **修正内容:**
    *   ルールボディのパース処理において、`_parse_term` が返す `Term('is', ...)` 構造を正しく認識し、ルールのボディ部 (Conjunction の一部) として含めるようにする。
    *   現状、ルールボディの各ゴールはコンマ (`,`) で区切られるか、ピリオド (`.`) で終了する。`Term('is', ...)` もこれらのゴールの一つとして扱われるようにする。
    *   `_parse_term` が `is` 式を正しく返せば、`_parse_rule` 側の大きな変更は不要かもしれないが、`Conjunction` オブジェクトの構築時に `Term('is', ...)` が適切に要素として追加されることを確認する。

*   **確認ポイント:**
    *   `_parse_rule` 内でゴールを読み込むループが `_parse_term` を呼び出している箇所。
    *   `Conjunction` オブジェクトが、`Term('is', ...)` を含む項のリストを正しく保持できるか。

### 4.3 算術式パーサー (`_parse_additive_expr`, `_parse_multiplicative_expr`, `_parse_primary_expr` 等)

*   **修正内容:**
    *   これらの既存の算術式パーサーが、`is` の右辺として出現する式を正しくパースできることを確認する。基本的には既存のロジックで対応できるはずだが、`_parse_term` から呼び出される際のコンテキストで問題がないかレビューする。
    *   特に、括弧や単項演算子 (`-`) の扱いが `is` の右辺でも適切であることを確認する。

## 5. テストケースの例

以下のPrologコードが正しくパースされることを確認する。

```prolog
% 単純な算術
calc(X, Y) :- Y is X * 2.

% 複数の演算
complex_calc(A, B, C, Result) :- Result is (A + B) * C.

% 変数を含む算術
add_vars(Val, Sum) :- X is Val, Y is X + 10, Sum is Y.
```

パース結果の内部表現 (AST) が期待通りであることをデバッガやログで確認する。
例: `calc(X,Y) :- is(Y, *(X, 2)).` のような構造。

## 6. 懸念事項と対策

*   **演算子の優先順位と結合性:** `is` 演算子自体の優先順位は低いが、右辺の算術式内部の演算子の優先順位 (`*`, `+` など) は既存の算術式パーサーに依存する。これがProlog標準と一致しているか確認が必要。
*   **エラーハンドリング:** 不正な算術式 (例: `Y is atom.`) が与えられた場合に、適切なエラーメッセージと共にパースが失敗することを確認する。

## 7. その他

特になし。
