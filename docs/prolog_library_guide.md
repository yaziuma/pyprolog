# Prolog ライブラリ (`pieprolog`) 利用ガイド

このドキュメントは、MCP Prolog Server プロジェクトで使用されている Prolog ライブラリ (`pieprolog`) の参照方法、使用上の注意点、および通常の Prolog との主な違いについて説明します。

## 1. ライブラリの参照方法

`pieprolog` ライブラリは、Python の標準的な方法でインポートして使用します。主要なクラスは `prolog.interpreter` および `prolog.types` モジュールで定義されています。

```python
from prolog.interpreter import Runtime
from prolog.types import Term, Variable, Number, Dot, Bar, TRUE, FALSE, CUT
```

`Runtime` クラスが Prolog インタプリタの主要なインスタンスです。Prolog のルールをロードし、クエリを実行するために使用します。

## 2. 使用上の注意点

- **Runtime インスタンスの管理:** `Runtime` クラスのインスタンスは、Prolog の知識ベース（ロードされたルールや事実）の状態を保持します。MCP サーバーのように状態を維持する必要があるアプリケーションでは、このインスタンスを適切に管理（例: シングルトンとして扱う）する必要があります。
- **エラーハンドリング:** ライブラリの操作中に発生する可能性のある例外（構文エラーなど）を適切にキャッチし、処理する必要があります。
- **組み込み述語:** `prolog.builtins` モジュールには、`Write`, `Nl`, `Tab`, `Fail`, `Cut`, `Retract`, `AssertA`, `AssertZ` などの組み込み述語に対応するクラスが含まれています。これらは Prolog コード内で使用される際に、インタプリタによって内部的に処理されます。
- **入出力:** `Runtime` クラスは内部にストリーム (`io.StringIO`) を持っており、`stream_write` で書き込み、`stream_read` で読み込みが可能です。これは `write/1` などの述語の出力を捕捉するのに利用できます。

## 3. 通常の Prolog との主な違い

`pieprolog` はシンプルな Prolog インタプリタであり、標準的な Prolog 処理系（SWI-Prolog など）と比較していくつかの重要な違いがあります。特に演算子、関数、組み込み述語において差異が見られます。

以下に、`pieprolog` と標準 Prolog の主な違いをまとめます。

| 標準 Prolog    | pieprolog | 用法・意味                                                                                     |
| -------------- | --------- | ---------------------------------------------------------------------------------------------- | ------ | ------------------------ |
| `=:=`          | `==`      | 算術式の値が等しいか評価                                                                       |
| `=\=`          | `=/`      | 算術式の値が等しくないか評価                                                                   |
| `=`            | なし      | 単一化（unification）を実行（演算子としてはサポートされていません）                            |
| `==`           | なし      | 厳密に等価かどうかを確認（単一化せず）（演算子としてはサポートされていません）                 |
| `\=`           | なし      | 単一化に失敗するかを確認（演算子としてはサポートされていません）                               |
| `=<`           | `=<`      | 小さいか等しい                                                                                 |
| `>=`           | `>=`      | 大きいか等しい                                                                                 |
| `<`            | `<`       | より小さい                                                                                     |
| `>`            | `>`       | より大きい                                                                                     |
| `is`           | `is`      | 右辺の算術式を評価し左辺に代入                                                                 |
| `assert/1`     | なし      | 動的にルールを追加（組み込み述語としてはサポートされていません）                               |
| `asserta/1`    | `asserta` | ルールをデータベースの先頭に追加                                                               |
| `assertz/1`    | `assertz` | ルールをデータベースの末尾に追加                                                               |
| `retract/1`    | `retract` | 指定されたルールを削除                                                                         |
| `retractall/1` | なし      | 指定されたパターンに一致するすべてのルールを削除（組み込み述語としてはサポートされていません） |
| `write/1`      | `write`   | 引数を出力                                                                                     |
| `nl/0`         | `nl`      | 改行を出力                                                                                     |
| `tab/1`        | `tab`     | 標準: N 個のスペースを出力、この実装: 引数なしでタブを出力                                     |
| `!/0`          | `!`       | カット。バックトラックを防ぐ（選択肢の打ち切り）                                               |
| `fail/0`       | `fail`    | 常に失敗する（バックトラック強制）                                                             |
| `true/0`       | `TRUE()`  | 常に成功する                                                                                   |
| `call/1`       | なし      | 引数を目標として呼び出す（組み込み述語としてはサポートされていません）                         |
| `\+`           | なし      | 論理否定（ゴールの失敗を確認）（演算子としてはサポートされていません）                         |
| `;`            | なし      | 論理和（OR）（演算子としてはサポートされていません）                                           |
| `,`            | `,`       | 論理積（AND）                                                                                  |
| `mod`          | なし      | 剰余演算（演算子としてはサポートされていません）                                               |
| `div`          | なし      | 整数除算（演算子としてはサポートされていません）                                               |
| `[Head         | Tail]`    | `[Head                                                                                         | Tail]` | リストの先頭と残りを分離 |
| `number/1`     | なし      | 引数が数値かどうかを確認（組み込み述語としてはサポートされていません）                         |
| `atom/1`       | なし      | 引数がアトムかどうかを確認（組み込み述語としてはサポートされていません）                       |
| `var/1`        | なし      | 引数が未束縛変数かどうかを確認（組み込み述語としてはサポートされていません）                   |

上記以外にも、標準的な Prolog が提供する多くの組み込み述語、ライブラリ、および高度な機能は `pieprolog` には実装されていません。特に、**否定 (`\+` または `not`) は演算子として直接サポートされていません**。通常の Prolog における「失敗による否定」の機能は利用できないため、論理的な否定を表現する際には異なるアプローチが必要になる場合があります。

pieprolog では、Prolog 文を構造化するために以下のクラスが使用されています：

1. **Term** - Prolog の述語（predicate）を表現する基本クラス
2. **Variable** - Prolog 変数を表現するクラス
3. **Conjunction** - 複数のゴールの論理積（AND 結合）を表現するクラス
4. **Rule** - Prolog ルール（head :- body）を表現するクラス
5. **Number** - 数値リテラルを表現するクラス
6. **TermFunction** - 関数呼び出しを表現するクラス
7. **Arithmetic** - 算術式を表現するクラス（Variable 継承）
8. **Logic** - 論理式を表現するクラス
9. **Dot** - リストの要素を表現するクラス
10. **Bar** - リストの分割表現（[Head|Tail]）を表現するクラス
11. **TRUE** - 常に成功する述語を表現するクラス（Term 継承）
12. **FALSE** - 常に失敗する述語を表現するクラス（Term 継承）
13. **CUT** - カット演算を表現するクラス（Term 継承）
14. **Fail** - 失敗を表現する組み込み述語クラス
15. **Cut** - カット演算を表現する組み込み述語クラス
16. **Write** - 出力を表現する組み込み述語クラス
17. **Nl** - 改行を表現する組み込み述語クラス
18. **Tab** - タブを表現する組み込み述語クラス
19. **DatabaseOp** - データベース操作の基底クラス
20. **Retract** - ルール削除を表現するクラス
21. **AssertA** - ルール先頭追加を表現するクラス
22. **AssertZ** - ルール末尾追加を表現するクラス

これらのクラスは、Prolog 言語の構文要素や操作を表現し、インタープリタが構文解析と実行を行うためのオブジェクト指向表現を提供しています。

これらの違いを理解し、`pieprolog` の機能範囲内で開発を行う必要があります。必要に応じて、`pieprolog` のソースコード（特に `interpreter.py`, `types.py`, `builtins.py`, `parser.py`, `scanner.py`）を参照して、具体的な挙動を確認することが重要です。
